"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const socket_io_client_1 = __importDefault(require("socket.io-client"));
const he_1 = require("he");
const node_events_1 = require("node:events");
const errors_1 = require("./errors");
class Client extends node_events_1.EventEmitter {
    socket;
    #name;
    #server;
    users = [];
    #userID;
    blockedIDs = new Set();
    blockedSessionIDs = new Set();
    commandPrefixes;
    commands = {
        help: (reply, ...args) => {
            return ["**List of available commands:**", Object.keys(this.commands).join(", ")];
        },
    };
    static default = Client;
    /**
     * Creates a new msgroom client.
     * @param name The username to use.
     * @param commandPrefixes List of prefixes to be used for commands. Do note these *will be pasted directly in a regular expression*, so **make sure to escape any special characters!**
     * @param server The server to connect to.
     */
    constructor(name, commandPrefixes = [], server = "wss://devel.windows96.net:4096") {
        super();
        this.#name = name;
        this.#server = server;
        this.commandPrefixes = typeof commandPrefixes == "string" ? [commandPrefixes] : commandPrefixes;
    }
    /**
     * Connect to a msgroom server. This should be the first function you run after creating a new instance of this class.
     * @param name The username you want to use.
     * @param server A URL to the server you want to connect to.
     * @param apikey You can request one from ctrlz.
     * @returns A promise which resolves when the connection has successfully been established.
     */
    async connect(name = this.#name, server = this.#server, apikey) {
        return new Promise((resolve, reject) => {
            if (name.length > 18)
                throw new Error("Username is longer than 18 characters.");
            if (name.length < 1)
                throw new Error("Username should be 1 character or more.");
            this.#name = name;
            this.#server = server;
            let userID;
            this.socket = (0, socket_io_client_1.default)(this.#server);
            this.socket // no you can't remove this line, that would break the types
                //#region connecting to the server
                .on("connect", () => {
                if (!this.socket)
                    throw new errors_1.NotConnectedError();
                this.socket.emit("auth", {
                    user: name,
                });
            })
                .on("disconnect", () => {
                this.emit("disconnected");
            })
                .on("connect_error", () => {
                throw new errors_1.ConnectionError();
            })
                .on("auth-complete", authenticatedUserID => {
                if (!this.socket)
                    throw new errors_1.NotConnectedError();
                this.socket.emit("online");
                userID = authenticatedUserID;
            })
                .on("auth-error", ({ reason }) => {
                reject(new errors_1.AuthError(reason));
            })
                .on("online", users => {
                this.users = users;
                this.#userID = userID;
                resolve();
            })
                //#endregion
                //#region main events
                .on("werror", reason => {
                this.emit("werror", reason);
            })
                .on("message", message => {
                if (this.isBlocked(message))
                    return;
                message.content = (0, he_1.decode)(message.content);
                this.emit("message", message);
                void this.processCommands(message.content);
            })
                .on("sys-message", sysMessage => {
                this.emit("sys-message", sysMessage);
                //@ts-ignore don't worry, it's fine. Typescript is just being dumb.
                this.emit(`sys-message-${sysMessage.type}`, sysMessage);
            })
                .on("nick-changed", nickChangeInfo => {
                if (this.isBlocked(nickChangeInfo))
                    return;
                const changedUserIndex = this.users.findIndex(user => user.id == nickChangeInfo.id && nickChangeInfo.session_id == user.id && nickChangeInfo.oldUser == user.user);
                if (changedUserIndex == -1)
                    return;
                this.users[changedUserIndex].user = nickChangeInfo.newUser;
                this.emit("nick-change", nickChangeInfo);
            })
                .on("user-join", user => {
                if (this.isBlocked(user))
                    return;
                this.users.push(user);
                this.emit("user-join", user);
            })
                .on("user-leave", userLeaveInfo => {
                if (this.isBlocked(userLeaveInfo))
                    return;
                const leftUserIndex = this.users.findIndex(user => user.id == userLeaveInfo.id && user.session_id == userLeaveInfo.session_id && user.user == userLeaveInfo.user);
                if (leftUserIndex == -1)
                    return;
                this.emit("user-leave", this.users[leftUserIndex]);
                this.users.splice(leftUserIndex, 1);
            })
                .on("user-update", userUpdateInfo => {
                const updatedUserIndex = this.users.findIndex(user => user.session_id == userUpdateInfo.user);
                if (updatedUserIndex == -1)
                    return;
                if (this.isBlocked(this.users[updatedUserIndex]))
                    return;
                switch (userUpdateInfo.type) {
                    case "tag-add":
                        if (!userUpdateInfo.tag || !userUpdateInfo.tagLabel)
                            return;
                        if (userUpdateInfo.tag.trim() == "")
                            return;
                        if (this.users[updatedUserIndex].flags.includes(userUpdateInfo.tag))
                            this.users[updatedUserIndex].flags.push(userUpdateInfo.tag);
                        this.emit("tag-add", this.users[updatedUserIndex], userUpdateInfo.tag, userUpdateInfo.tagLabel);
                }
            });
            //#endregion
            this.socket.emit("auth", {
                user: name,
                apikey,
            });
        });
    }
    disconnect() {
        this.socket?.disconnect();
    }
    get server() {
        return this.#server;
    }
    get name() {
        return this.#name;
    }
    set name(name) {
        if (!this.socket)
            throw new errors_1.NotConnectedError();
        if (name.length > 18)
            throw new Error("Username is longer than 18 characters.");
        if (name.length < 1)
            throw new Error("Username should be 1 character or more.");
        this.socket.emit("change-user", name);
    }
    get userID() {
        if (!this.#userID)
            throw new errors_1.NotConnectedError();
        return this.#userID;
    }
    sendMessage(...messages) {
        if (!this.socket)
            throw new errors_1.NotConnectedError();
        const message = messages.join(" ");
        if (message.length > 2048)
            return void this.emit("werror", "message too long");
        this.socket.emit("message", {
            type: "text",
            content: message,
        });
    }
    /**
     * We currently have no idea what this could be, apart from what the type must be according to the code of the official msgroom client.
     * @param args The arguments to pass to the `admin-action` event.
     */
    adminAction(...args) {
        if (!this.socket)
            throw new errors_1.NotConnectedError();
        this.socket.emit("admin-action", { args });
    }
    getCommand(command, commandArguments) {
        let currentGottenHandler = this.commands;
        while (typeof currentGottenHandler != "undefined") {
            currentGottenHandler = currentGottenHandler[command];
            if (!currentGottenHandler)
                return;
            if (typeof currentGottenHandler == "function")
                return [currentGottenHandler, commandArguments];
            command = commandArguments[0];
            commandArguments.splice(0, 1);
        }
    }
    async processCommands(message, reply = (...args) => this.sendMessage(...args)) {
        const regex = new RegExp(`^(${this.commandPrefixes.join("|")})`, "i");
        if (!regex.test(message))
            return;
        const commandArguments = message.replace(regex, "").split(" ");
        const command = commandArguments[0];
        commandArguments.splice(0, 1);
        const gottenCommand = this.getCommand(command, commandArguments);
        // We can safely assume there is at least one prefix, because otherwise this method wouldn't be called.
        if (!gottenCommand)
            return reply(`That command doesn't exist. Run ${this.commandPrefixes[0]}help for a list of commands.`);
        const [commandHandler, commandHandlerArguments] = gottenCommand;
        try {
            const commandResult = await commandHandler(reply, ...commandHandlerArguments);
            if (!commandResult)
                return;
            if (typeof commandResult == "string")
                return reply(commandResult);
            return reply(...commandResult);
        }
        catch (error) {
            reply(`An error occured while executing ${command}: *${error}*`);
        }
    }
    isBlocked(userIDOrObject, userSessionID) {
        let blocked = false;
        if (typeof userIDOrObject == "string")
            blocked ||= this.blockedIDs.has(userIDOrObject);
        else if (!(typeof userIDOrObject == "undefined"))
            blocked ||= this.blockedIDs.has(userIDOrObject.id)
                || this.blockedSessionIDs.has(userIDOrObject.sessionID)
                || this.blockedSessionIDs.has(userIDOrObject.session_id);
        if (typeof userSessionID == "string")
            blocked ||= this.blockedSessionIDs.has(userSessionID);
        return blocked;
    }
}
module.exports = Client;
