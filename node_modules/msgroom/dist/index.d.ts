import { User } from "./socket.io";
import TypedEmitter from "typed-emitter";
import ClientEvents from "./events";
type LogFunction = (...args: string[]) => void;
type CommandHandler = (reply: LogFunction, ...args: string[]) => (Promise<string | string[] | void> | string | string[] | void);
type CommandHandlerMap = {
    [key: string]: CommandHandler | CommandHandlerMap;
};
declare const Client_base: new () => TypedEmitter<ClientEvents>;
declare class Client extends Client_base {
    #private;
    private socket?;
    users: User[];
    blockedIDs: Set<string>;
    blockedSessionIDs: Set<string>;
    commandPrefixes: string[];
    commands: CommandHandlerMap;
    static default: typeof Client;
    /**
     * Creates a new msgroom client.
     * @param name The username to use.
     * @param commandPrefixes List of prefixes to be used for commands. Do note these *will be pasted directly in a regular expression*, so **make sure to escape any special characters!**
     * @param server The server to connect to.
     */
    constructor(name: string, commandPrefixes?: string | string[], server?: string);
    /**
     * Connect to a msgroom server. This should be the first function you run after creating a new instance of this class.
     * @param name The username you want to use.
     * @param server A URL to the server you want to connect to.
     * @param apikey You can request one from ctrlz.
     * @returns A promise which resolves when the connection has successfully been established.
     */
    connect(name?: string, server?: string, apikey?: string): Promise<void>;
    disconnect(): void;
    get server(): string;
    get name(): string;
    set name(name: string);
    get userID(): string;
    sendMessage(...messages: string[]): void;
    /**
     * We currently have no idea what this could be, apart from what the type must be according to the code of the official msgroom client.
     * @param args The arguments to pass to the `admin-action` event.
     */
    adminAction(...args: string[]): void;
    getCommand(command: string, commandArguments: string[]): [CommandHandler, string[]] | undefined;
    processCommands(message: string, reply?: LogFunction): Promise<void>;
    isBlocked(userID: string, userSessionID?: string): boolean;
    isBlocked(userIDOrObject: {
        id?: string;
        sessionID?: string;
        session_id?: string;
    }): boolean;
}
export = Client;
